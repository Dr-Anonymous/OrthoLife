# Deployment Guide for Pre-rendered Site

This guide explains how to configure your web server to correctly serve the pre-rendered static HTML files generated by the `npm run build` command.

## Build Output Structure

After a successful build, the `build/` directory will contain all the static assets for your site. The structure is as follows:

- **`build/index.html`**: The fallback HTML file for the root of the site.
- **`build/assets/`**: Contains all the JavaScript, CSS, images, and other static assets.
- **`build/appointment/index.html`**: A pre-rendered HTML file for the `/appointment` route.
- **`build/blog/1/index.html`**: A pre-rendered HTML file for the `/blog/1` route.
- ...and so on for every page defined in your sitemap.

## Core Serving Principle

Your web server must be configured to serve the static HTML file that corresponds to the requested URL. For a given path, it should look for a directory with the same name and serve the `index.html` file within it.

For example:
- A request to `https://yourdomain.com/` should serve `build/index.html`.
- A request to `https://yourdomain.com/appointment` should serve `build/appointment/index.html`.
- A request to `https://yourdomain.com/blog/1` should serve `build/blog/1/index.html`.

This is a common configuration for serving static sites. The `try_files` directive in Nginx or similar features in other servers are perfect for this.

---

## Example Nginx Configuration

Here is a sample Nginx `server` block that implements the correct serving logic. You can adapt this to your existing Nginx configuration.

```nginx
server {
    listen 80;
    server_name ortho.life www.ortho.life;

    # The root directory should point to your build output
    root /path/to/your/project/build;

    # Default file to serve
    index index.html;

    location / {
        # This is the key directive. It tries to find a file that matches the
        # request URI directly ($uri). If not found, it checks if a directory
        # with that name exists and serves its index.html ($uri/index.html).
        # If neither is found, it falls back to the root index.html,
        # allowing client-side routing to take over for any routes that might
        # not have been pre-rendered.
        try_files $uri $uri/index.html /index.html;
    }

    # Optional: Add caching headers for static assets to improve performance
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```
**To use this:**
1. Replace `/path/to/your/project/build` with the actual absolute path to your `build` directory.
2. Place this configuration in your Nginx `sites-available` directory and create a symlink in `sites-enabled`.
3. Reload Nginx: `sudo systemctl reload nginx`.

---

## Other Hosting Platforms

### Vercel / Netlify
Platforms like Vercel and Netlify are designed for modern web applications and will typically handle this automatically. You just need to:
1. Point the platform to your Git repository.
2. Configure the build command to `npm run build`.
3. Configure the output directory (sometimes called "Publish directory") to `build`.
Their systems will automatically serve the correct HTML files for each route.

### AWS S3 + CloudFront
When using AWS S3 for static site hosting, you can achieve this by:
1. **Uploading the `build` directory contents** to your S3 bucket.
2. **Configuring CloudFront** as your CDN.
3. **Using a CloudFront Function or Lambda@Edge** to rewrite requests. A request to `/appointment` needs to be rewritten to `/appointment/index.html` before it hits the S3 origin. This is the standard way to handle "clean URLs" with S3 static hosting.
